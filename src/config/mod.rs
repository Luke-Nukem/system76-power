mod backlight;
mod defaults;
mod profile;
mod pstate;
mod thresholds;

pub use self::backlight::*;
pub use self::defaults::*;
pub use self::profile::*;
pub use self::pstate::*;
pub use self::thresholds::*;

use sysfs_class::RuntimePowerManagement;
use std::fs::{self, File};
use std::io::{self, Read, Write};
use std::path::{Path, PathBuf};
use std::str;
use toml;

const CONFIG_PARENT: &str = "/etc/system76-power/";
const CONFIG_PATH: &str = "/etc/system76-power/config.toml";

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Config {
    #[serde(default)]
    #[serde(flatten)]
    pub defaults: ConfigDefaults,

    #[serde(default)]
    pub thresholds: ConfigThresholds,

    #[serde(default)]
    pub profiles: Profiles,
}

impl Config {
    /// Attempts to get the current configuration from the `CONFIG_PATH`.
    ///
    /// If an error occurs, the default config will be used instead, which will
    /// allow the daemon to continue operating with the recommended defaults.
    pub fn new() -> io::Result<Config> {
        let config_path = &Path::new(CONFIG_PATH);
        if !config_path.exists() {
            info!("config file does not exist at {}; creating it", CONFIG_PATH);
            let config = Config::default();

            if let Err(why) = config.write() {
                error!("failed to write config to file system: {}", why);
            }

            Ok(config)
        } else {
            Config::read()
        }
    }

    /// Update the config at the `CONFIG_PATH`.
    pub fn write(&self) -> io::Result<()> {
        let config_path = &Path::new(CONFIG_PATH);
        let config_parent = &Path::new(CONFIG_PARENT);

        if !config_parent.exists() {
            fs::create_dir(config_parent)?;
        }

        let mut file = File::create(config_path)?;
        file.write_all(&self.serialize())?;

        Ok(())
    }

    /// Attempt to read the configuration file at the `CONFIG_PATH`.
    fn read() -> io::Result<Config> {
        let config_path = &Path::new(CONFIG_PATH);
        let mut file = File::open(config_path)?;
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)?;

        toml::from_slice(&buffer).map_err(|why| {
            io::Error::new(
                io::ErrorKind::Other,
                format!("failed to deserialize config: {}", why),
            )
        })
    }

    /// Custom serialization to a more readable format.
    fn serialize(&self) -> Vec<u8> {
        let mut out = Vec::with_capacity(8 * 1024);
        {
            let out = &mut out;
            out.extend_from_slice(
                b"# This config is automatically generated by system76-power.\n\n",
            );
            self.defaults.serialize_toml(out);
            self.thresholds.serialize_toml(out);
            self.profiles.serialize_toml(out);
        }
        out
    }
}

// TODO: Make this configurable.
pub struct ProfileParameters {
    pub profile: ProfileKind,
    pub disk_apm: u8,
    pub disk_autosuspend_delay: i32,
    pub scsi_profiles: &'static [&'static str],
    pub sound_power_save: (u32, bool),
    pub radeon_profile: &'static str,
    pub radeon_dpm_state: &'static str,
    pub radeon_dpm_perf: &'static str,
    pub pci_runtime_pm: RuntimePowerManagement,
    pub max_lost_work: u32,
    pub laptop_mode: &'static [u8],
    pub pstate_defaults: ConfigPState,
    pub backlight_screen: Option<u8>,
    pub backlight_keyboard: Option<u8>,
}

fn comment_if_default<T: PartialEq>(
    quote: bool,
    field: &str,
    default: T,
    new: T,
    as_str: &str,
) -> String {
    match (default == new, quote) {
        (true, true) => ["# ", field, " = '", as_str, "'"].concat(),
        (true, false) => ["# ", field, " = ", as_str].concat(),
        (false, true) => [field, " = '", as_str, "'"].concat(),
        (false, false) => [field, " = ", as_str].concat(),
    }
}
